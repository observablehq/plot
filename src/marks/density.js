import {contourDensity, create, geoPath} from "d3";
import {identity, maybeTuple, maybeZ, valueof} from "../options.js";
import {Mark} from "../plot.js";
import {coerceNumbers} from "../scales.js";
import {applyFrameAnchor, applyDirectStyles, applyIndirectStyles, applyChannelStyles, applyTransform, distinct, groupZ} from "../style.js";
import {initializer} from "../transforms/basic.js";

const defaults = {
  ariaLabel: "density",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: 1
};

export class Density extends Mark {
  constructor(data, {x, y, z, weight, fill, stroke, ...options} = {}) {
    // If fill or stroke is specified as “density”, then temporarily treat these
    // as a literal color when computing defaults and maybeZ; below, we’ll unset
    // these constant colors back to undefined since they will instead be
    // populated by a channel generated by the initializer.
    const fillDensity = isDensity(fill) && (fill = "currentColor", true);
    const strokeDensity = isDensity(stroke) && (stroke = "currentColor", true);
    super(
      data,
      [
        {name: "x", value: x, scale: "x", optional: true},
        {name: "y", value: y, scale: "y", optional: true},
        {name: "z", value: maybeZ({z, fill, stroke}), optional: true},
        {name: "weight", value: weight, optional: true}
      ],
      densityInitializer({...options, fill, stroke}, fillDensity, strokeDensity),
      defaults
    );
    if (fillDensity) this.fill = undefined;
    if (strokeDensity) this.stroke = undefined;
    this.z = z;
  }
  filter(index) {
    return index; // don’t filter contours constructed by initializer
  }
  render(index, scales, channels, dimensions) {
    const {contours} = channels;
    const path = geoPath();
    return create("svg:g")
        .call(applyIndirectStyles, this, scales, dimensions)
        .call(applyTransform, this, scales)
        .call(g => g.selectAll()
          .data(index)
          .enter()
          .append("path")
            .call(applyDirectStyles, this)
            .call(applyChannelStyles, this, channels)
            .attr("d", i => path(contours[i])))
        .node();
  }
}

export function density(data, {x, y, ...options} = {}) {
  ([x, y] = maybeTuple(x, y));
  return new Density(data, {...options, x, y});
}

const dropChannels = new Set(["x", "y", "z", "weight"]);

function densityInitializer(options, fillDensity, strokeDensity) {
  let {bandwidth, thresholds} = options;
  bandwidth = bandwidth === undefined ? 20 : +bandwidth;
  thresholds = thresholds === undefined ? 20 : +thresholds; // TODO Allow an array of thresholds?
  return initializer(options, function(data, facets, channels, scales, dimensions) {
    const X = channels.x ? coerceNumbers(valueof(channels.x.value, scales[channels.x.scale] || identity)) : null;
    const Y = channels.y ? coerceNumbers(valueof(channels.y.value, scales[channels.y.scale] || identity)) : null;
    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;
    const Z = channels.z?.value;
    const {z} = this;
    const [cx, cy] = applyFrameAnchor(this, dimensions);
    const {width, height} = dimensions;

    // Group any of the input channels according to the first index associated
    // with each z-series or facet. Drop any channels not be needed for
    // rendering after the contours are computed.
    const newChannels = Object.fromEntries(Object.entries(channels)
      .filter(([key]) => !dropChannels.has(key))
      .map(([key, channel]) => [key, {...channel, value: []}]));

    // If the fill or stroke encodes density, construct new output channels.
    const FD = fillDensity && [];
    const SD = strokeDensity && [];
    const k = 100; // arbitrary scale factor for readability

    const density = contourDensity()
        .x(X ? i => X[i] : cx)
        .y(Y ? i => Y[i] : cy)
        .weight(W ? i => W[i] : 1)
        .size([width, height])
        .bandwidth(bandwidth)
        .thresholds(thresholds);

    // If there are multiple facets or multiple series, first compute the
    // contours for each facet-series independently; choose the set of contours
    // with the maximum threshold value (density), and then apply this set’s
    // thresholds to all the other facet-series. TODO With API changes to
    // d3-contour, we could avoid recomputing the blurred grid and cache
    // individual contours, making this more efficient.
    if (facets.length > 1 || Z && facets.length > 0 && distinct(facets[0], Z)) {
      let maxValue = 0;
      let maxContours = [];
      for (const facet of facets) {
        for (const index of Z ? groupZ(facet, Z, z) : [facet]) {
          const C = density(index);
          if (C.length > 0) {
            const c = C[C.length - 1];
            if (c.value > maxValue) {
              maxValue = c.value;
              maxContours = C;
            }
          }
        }
      }
      density.thresholds(maxContours.map(c => c.value));
    }

    // Generate contours for each facet-series.
    const newFacets = [];
    const contours = [];
    for (const facet of facets) {
      const contourFacet = [];
      newFacets.push(contourFacet);
      for (const index of Z ? groupZ(facet, Z, z) : [facet]) {
        for (const contour of density(index)) {
          contourFacet.push(contours.length);
          contours.push(contour);
          if (FD) FD.push(contour.value * k);
          if (SD) SD.push(contour.value * k);
          for (const key in newChannels) {
            newChannels[key].value.push(channels[key].value[index[0]]);
          }
        }
      }
    }

    // If the fill or stroke encodes density, ensure that a zero value is
    // included so that the default color scale domain starts at zero. Otherwise
    // if the starting range value is the same as the background color, the
    // first contour might not be visible.
    if (FD) FD.push(0);
    if (SD) SD.push(0);

    return {
      data,
      facets: newFacets,
      channels: {
        ...newChannels,
        ...FD && {fill: {value: FD, scale: "color"}},
        ...SD && {stroke: {value: SD, scale: "color"}},
        contours: {value: contours}
      }
    };
  });
}

function isDensity(value) {
  return /^density$/i.test(value);
}
